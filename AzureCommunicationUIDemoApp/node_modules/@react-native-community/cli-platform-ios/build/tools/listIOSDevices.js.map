{"version":3,"names":["promptForDeviceSelection","availableDevices","device","prompts","type","name","message","choices","filter","d","map","title","chalk","bold","value","min","parseXcdeviceList","text","rawOutput","JSON","parse","devices","platform","includes","sort","simulator","isAvailable","available","udid","identifier","version","operatingSystemVersion","availabilityError","error","description","listIOSDevices","out","execa","sync","stdout"],"sources":["../../src/tools/listIOSDevices.ts"],"sourcesContent":["import {Device} from '../types';\nimport execa from 'execa';\nimport prompts from 'prompts';\nimport chalk from 'chalk';\n\ntype DeviceOutput = {\n  modelCode: string;\n  simulator: boolean;\n  modelName: string;\n  error: {\n    code: number;\n    failureReason: string;\n    underlyingErrors: [\n      {\n        code: number;\n        failureReason: string;\n        description: string;\n        recoverySuggestion: string;\n        domain: string;\n      },\n    ];\n    description: string;\n    recoverySuggestion: string;\n    domain: string;\n  };\n  operatingSystemVersion: string;\n  identifier: string;\n  platform: string;\n  architecture: string;\n  interface: string;\n  available: boolean;\n  name: string;\n  modelUTI: string;\n};\n\nexport async function promptForDeviceSelection(\n  availableDevices: Device[],\n): Promise<Device | undefined> {\n  const {device} = await prompts({\n    type: 'select',\n    name: 'device',\n    message: 'Select the device you want to use',\n    choices: availableDevices\n      .filter((d) => d.type === 'device' || d.type === 'simulator')\n      .map((d) => ({\n        title: `${chalk.bold(d.name)}`,\n        value: d,\n      })),\n    min: 1,\n  });\n  return device;\n}\n\nconst parseXcdeviceList = (text: string): Device[] => {\n  const rawOutput = JSON.parse(text) as DeviceOutput[];\n\n  const devices: Device[] = rawOutput\n    .filter(\n      (device) =>\n        !device.platform.includes('appletv') &&\n        !device.platform.includes('macos'),\n    )\n    .sort((device) => (device.simulator ? 1 : -1))\n    .map((device) => ({\n      isAvailable: device.available,\n      name: device.name,\n      udid: device.identifier,\n      version: device.operatingSystemVersion,\n      availabilityError: device.error?.description,\n      type: device.simulator ? 'simulator' : 'device',\n    }));\n  return devices;\n};\n\nfunction listIOSDevices(): Device[] {\n  const out = execa.sync('xcrun', ['xcdevice', 'list']).stdout;\n  return parseXcdeviceList(out);\n}\n\nexport default listIOSDevices;\n"],"mappings":";;;;;;;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAA0B;AAgCnB,eAAeA,wBAAwB,CAC5CC,gBAA0B,EACG;EAC7B,MAAM;IAACC;EAAM,CAAC,GAAG,MAAM,IAAAC,kBAAO,EAAC;IAC7BC,IAAI,EAAE,QAAQ;IACdC,IAAI,EAAE,QAAQ;IACdC,OAAO,EAAE,mCAAmC;IAC5CC,OAAO,EAAEN,gBAAgB,CACtBO,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACL,IAAI,KAAK,QAAQ,IAAIK,CAAC,CAACL,IAAI,KAAK,WAAW,CAAC,CAC5DM,GAAG,CAAED,CAAC,KAAM;MACXE,KAAK,EAAG,GAAEC,gBAAK,CAACC,IAAI,CAACJ,CAAC,CAACJ,IAAI,CAAE,EAAC;MAC9BS,KAAK,EAAEL;IACT,CAAC,CAAC,CAAC;IACLM,GAAG,EAAE;EACP,CAAC,CAAC;EACF,OAAOb,MAAM;AACf;AAEA,MAAMc,iBAAiB,GAAIC,IAAY,IAAe;EACpD,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAmB;EAEpD,MAAMI,OAAiB,GAAGH,SAAS,CAChCV,MAAM,CACJN,MAAM,IACL,CAACA,MAAM,CAACoB,QAAQ,CAACC,QAAQ,CAAC,SAAS,CAAC,IACpC,CAACrB,MAAM,CAACoB,QAAQ,CAACC,QAAQ,CAAC,OAAO,CAAC,CACrC,CACAC,IAAI,CAAEtB,MAAM,IAAMA,MAAM,CAACuB,SAAS,GAAG,CAAC,GAAG,CAAC,CAAE,CAAC,CAC7Cf,GAAG,CAAER,MAAM;IAAA;IAAA,OAAM;MAChBwB,WAAW,EAAExB,MAAM,CAACyB,SAAS;MAC7BtB,IAAI,EAAEH,MAAM,CAACG,IAAI;MACjBuB,IAAI,EAAE1B,MAAM,CAAC2B,UAAU;MACvBC,OAAO,EAAE5B,MAAM,CAAC6B,sBAAsB;MACtCC,iBAAiB,mBAAE9B,MAAM,CAAC+B,KAAK,kDAAZ,cAAcC,WAAW;MAC5C9B,IAAI,EAAEF,MAAM,CAACuB,SAAS,GAAG,WAAW,GAAG;IACzC,CAAC;EAAA,CAAC,CAAC;EACL,OAAOJ,OAAO;AAChB,CAAC;AAED,SAASc,cAAc,GAAa;EAClC,MAAMC,GAAG,GAAGC,gBAAK,CAACC,IAAI,CAAC,OAAO,EAAE,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAACC,MAAM;EAC5D,OAAOvB,iBAAiB,CAACoB,GAAG,CAAC;AAC/B;AAAC,eAEcD,cAAc;AAAA"}